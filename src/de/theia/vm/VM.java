package de.theia.vm;

import java.util.Stack;

/**
 * Virtual machine to execute the bytecode generated by {@link Compiler}
 * 
 * @author maximilianstrauch
 */
public class VM {

    /**
     * The "program" of the VM
     */
    private final int[] bytecode;
    
    /**
     * The program counter
     */
    private int pc;
    
    /**
     * Reference to the register file of the register machine
     */
    private final Register register;
    
    /**
     * The VM's stack
     */
    private final Stack<Integer> stack;
    
    /**
     * Status indicators
     */
    private boolean isRunning, isDone;
    
    /**
     * Creates a new VM instance
     * 
     * @param bytecode The "program" to run
     */
    public VM(int[] bytecode) {
        this.bytecode = bytecode;
        this.register = Register.getInstance();
        this.stack = new Stack<>();
        this.pc = 0;
        this.stack.clear();
        this.isRunning = false;
        this.isDone = false;
    }
    
    public synchronized final void stop() {
        isRunning = false;
    }
    
    public boolean isRunning() {
        return isRunning;
    }
    
    /**
     * Checks if the VM is done
     * 
     * @return <code>true</code> if the VM is done or <code>false</code>
     */
    public boolean isDone() {
        return isDone;
    }
    
    /**
     * Runs the VM
     */
    public void execute() {
        isRunning = true;
        isDone = true;
        int a, b, src, dst, addr;
        
        // Execute bytecode
        while (pc < bytecode.length) {
            
            if (isRunning == false) {
                break;
            }
            
            // Get the next instruction
            switch (bytecode[pc++]) {

                /*
                 * Arithmetic instructions
                 */
                
                // Register & immediate add
                case 0x2a: // add <a> <b> <dst>
                    a = getValue(bytecode[pc++]);
                    b = getValue(bytecode[pc++]);
                    dst = bytecode[pc++] & 0x7fffffff;
                    register.setValue(dst, a + b);
                    break;
                    
                // Register & immediate subtract
                case 0x2b: // sub <a> <b> <dst>
                    a = getValue(bytecode[pc++]);
                    b = getValue(bytecode[pc++]);
                    dst = bytecode[pc++] & 0x7fffffff;
                    
                    // Make sure that we don't get negative
                    src = a - b;
                    if (src < 0) {
                        src = 0;
                    }
                    
                    register.setValue(dst, src);
                    break;
                    
                // Register & immediate multiply
                case 0x2c: // mul <a> <b> <dst>
                    a = getValue(bytecode[pc++]);
                    b = getValue(bytecode[pc++]);
                    dst = bytecode[pc++] & 0x7fffffff;
                    register.setValue(dst, a * b);
                    break;
                    
                // Move register value
                case 0x2d: // mov <src> <dst>
                    src = getValue(bytecode[pc++]);
                    dst = bytecode[pc++] & 0x7fffffff;
                    register.setValue(dst, src);
                    break;
                    
                /*
                 * Stack instructions
                 */
                
                // Push value onto the stack
                case 0x10: // push <a>
                    a = getValue(bytecode[pc++]);
                    stack.push(a);
                    break;
                
                // Pop value from stack
                case 0x11: // pop
                    stack.pop();
                    break;
                    
                // Decrement topmost value of stack
                case 0x12: // dec
                    stack.push(stack.pop() - 1);
                    break;
                    
                // Branch if value on stack is zero
                case 0x13: // bz <addr>
                    addr = bytecode[pc++] & 0x7fffffff;
                    if (stack.peek() == 0) {
                        pc = addr;
                    }
                    break;
                    
                /*
                 * Jump and if instructions
                 */
                    
                // Goto address
                case 0x21: // goto <addr>
                    pc = bytecode[pc++] & 0x7fffffff;
                    break;
                    
                // If not equal
                case 0x42: // ifneq <a> <b> <addr>
                    a = getValue(bytecode[pc++]);
                    b = getValue(bytecode[pc++]);
                    if (a != b) {
                        pc = bytecode[pc++] & 0x7fffffff;
                    } else {
                        pc++;
                    }
                    break;
                    
                // If greater than
                case 0x43: // ifgt <a> <b> <addr>
                    a = getValue(bytecode[pc++]);
                    b = getValue(bytecode[pc++]);
                    if (a > b) {
                        pc = bytecode[pc++] & 0x7fffffff;
                    } else {
                        pc++;
                    }
                    break;
                    
                // If equals
                case 0x44: // ifeq <a> <b> <addr>
                    a = getValue(bytecode[pc++]);
                    b = getValue(bytecode[pc++]);
                    if (a == b) {
                        pc = bytecode[pc++] & 0x7fffffff;
                    } else {
                        pc++;
                    }
                    break; 
                    
                /*
                 * Other instructions
                 */
                    
                // No operation
                case 0x99: // nop
                    break;
                    
                default:
                    throw new VMException(
                            String.format("Unkown opcode 0x%02x", bytecode[pc-1])
                    );
                
            }
            
        }
        
        isRunning = false;
        isDone = true;
    }
    
    /**
     * Returns a value for an immediate or register
     * 
     * @param arg The immediate or register value
     * @return The actual data value
     */
    private int getValue(int arg) {
        if ((arg & 0x80000000) != 0) {
            // Register value if MSB set
            int reg = arg & 0x7fffffff;
            return register.getValue(reg);
        } else {
            // Immediate value
            return arg & 0x7fffffff;
        }
    }
    
}
